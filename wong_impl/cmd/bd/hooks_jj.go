// hooks_jj.go adapts the beads hooks system for Jujutsu (jj) VCS.
//
// jj has no native hook system -- its philosophy is "everything is a change"
// and hooks are unnecessary. Beads still needs explicit sync points, so we
// provide wrapper scripts that users can alias to jj subcommands. The
// wrappers call `bd hooks run <hook>` (reusing the existing hook logic)
// before exec-ing the real jj command.
//
// Installation creates:
//   - .beads/jj-hooks.toml   -- records which hooks are enabled
//   - .beads/bin/jj-commit   -- wrapper: pre-commit hook + jj commit
//   - .beads/bin/jj-push     -- wrapper: pre-push hook + jj git push
//   - .beads/bin/jj-fetch    -- wrapper: post-merge hook + jj git fetch
package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// jjHookDefs maps wrapper names to their hook and jj command.
var jjHookDefs = []struct {
	Name        string // wrapper script name (without "jj-" prefix in some cases)
	Hook        string // bd hook to run
	JJCommand   string // jj subcommand to exec
	Description string // human-readable purpose
}{
	{"jj-commit", "pre-commit", "jj commit", "Flush pending JSONL changes before jj commit"},
	{"jj-push", "pre-push", "jj git push", "Ensure JSONL is up-to-date before jj git push"},
	{"jj-fetch", "post-merge", "jj git fetch", "Import JSONL after fetching remote changes"},
}

// JJHookStatus reports the state of a single jj hook wrapper.
type JJHookStatus struct {
	Name        string // wrapper script name, e.g. "jj-commit"
	Installed   bool   // true if the wrapper script exists on disk
	WrapperPath string // absolute path to the wrapper script
	Description string // what this hook does
}

// jjHooksAvailable returns true if the current repo can use jj hooks.
// It checks for a .jj/ directory at the repository root (or cwd).
func jjHooksAvailable() bool {
	// Walk up from cwd looking for .jj/
	dir, err := os.Getwd()
	if err != nil {
		return false
	}
	for {
		if info, err := os.Stat(filepath.Join(dir, ".jj")); err == nil && info.IsDir() {
			return true
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return false
}

// installJJHooks sets up jj hook integration for the given repository root.
//
// Since jj has no native hook mechanism this creates:
//   - .beads/jj-hooks.toml listing enabled hooks
//   - .beads/bin/<wrapper> shell scripts that run `bd hooks run` then exec jj
func installJJHooks(repoRoot string) error {
	beadsDir := filepath.Join(repoRoot, ".beads")
	binDir := filepath.Join(beadsDir, "bin")

	// Ensure directories exist
	if err := os.MkdirAll(binDir, 0755); err != nil {
		return fmt.Errorf("creating .beads/bin: %w", err)
	}

	// Write jj-hooks.toml config
	tomlPath := filepath.Join(beadsDir, "jj-hooks.toml")
	if err := writeJJHooksConfig(tomlPath); err != nil {
		return fmt.Errorf("writing jj-hooks.toml: %w", err)
	}

	// Write wrapper scripts
	for _, def := range jjHookDefs {
		wrapperPath := filepath.Join(binDir, def.Name)
		content := jjHookWrapperScript(def.Hook, def.JJCommand)
		// #nosec G306 -- wrapper scripts must be executable
		if err := os.WriteFile(wrapperPath, []byte(content), 0755); err != nil {
			return fmt.Errorf("writing wrapper %s: %w", def.Name, err)
		}
	}

	return nil
}

// writeJJHooksConfig writes the .beads/jj-hooks.toml file listing enabled hooks.
func writeJJHooksConfig(path string) error {
	var sb strings.Builder
	sb.WriteString("# jj-hooks.toml -- jj hook integration for beads\n")
	sb.WriteString("#\n")
	sb.WriteString("# jj has no native hook system. Instead, beads provides wrapper scripts\n")
	sb.WriteString("# in .beads/bin/ that run `bd hooks run <hook>` before exec-ing jj.\n")
	sb.WriteString("#\n")
	sb.WriteString("# Add .beads/bin to your PATH, or create shell aliases:\n")
	sb.WriteString("#   alias jj-commit='.beads/bin/jj-commit'\n")
	sb.WriteString("#   alias jj-push='.beads/bin/jj-push'\n")
	sb.WriteString("#   alias jj-fetch='.beads/bin/jj-fetch'\n")
	sb.WriteString("#\n")
	sb.WriteString("# Generated by: bd hooks install (jj mode)\n")
	sb.WriteString("\n")

	for _, def := range jjHookDefs {
		sb.WriteString(fmt.Sprintf("[hooks.%s]\n", def.Name))
		sb.WriteString(fmt.Sprintf("enabled = true\n"))
		sb.WriteString(fmt.Sprintf("hook = %q\n", def.Hook))
		sb.WriteString(fmt.Sprintf("description = %q\n", def.Description))
		sb.WriteString("\n")
	}

	// #nosec G306 -- config file, no special permissions needed
	return os.WriteFile(path, []byte(sb.String()), 0644)
}

// jjHookStatus returns the status of all jj hook wrappers.
func jjHookStatus(repoRoot string) ([]JJHookStatus, error) {
	binDir := filepath.Join(repoRoot, ".beads", "bin")
	statuses := make([]JJHookStatus, 0, len(jjHookDefs))

	for _, def := range jjHookDefs {
		wrapperPath := filepath.Join(binDir, def.Name)
		installed := false
		if info, err := os.Stat(wrapperPath); err == nil && !info.IsDir() {
			installed = true
		}
		statuses = append(statuses, JJHookStatus{
			Name:        def.Name,
			Installed:   installed,
			WrapperPath: wrapperPath,
			Description: def.Description,
		})
	}

	return statuses, nil
}

// runJJPreCommit runs the pre-commit equivalent for jj: flush pending JSONL
// changes before jj commit.
func runJJPreCommit(ctx context.Context, repoRoot string) error {
	// Check if we're in a bd workspace
	beadsDir := filepath.Join(repoRoot, ".beads")
	if _, err := os.Stat(beadsDir); os.IsNotExist(err) {
		return nil // Not a bd workspace, nothing to do
	}

	// Flush pending changes to JSONL
	// #nosec G204 -- command is hardcoded
	cmd := exec.CommandContext(ctx, "bd", "sync", "--flush-only", "--no-daemon")
	cmd.Dir = repoRoot
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("flushing JSONL before jj commit: %w\nOutput: %s", err, string(output))
	}

	return nil
}

// runJJPostMerge runs the post-merge equivalent for jj: import JSONL after
// workspace changes (e.g., after jj git fetch).
func runJJPostMerge(ctx context.Context, repoRoot string) error {
	// Check if we're in a bd workspace
	beadsDir := filepath.Join(repoRoot, ".beads")
	if _, err := os.Stat(beadsDir); os.IsNotExist(err) {
		return nil
	}

	// Check if any JSONL file exists
	hasJSONL := false
	for _, f := range jsonlFilePaths {
		if _, err := os.Stat(filepath.Join(repoRoot, f)); err == nil {
			hasJSONL = true
			break
		}
	}
	if !hasJSONL {
		return nil
	}

	// Import JSONL
	// #nosec G204 -- command is hardcoded
	cmd := exec.CommandContext(ctx, "bd", "sync", "--import-only", "--no-git-history", "--no-daemon")
	cmd.Dir = repoRoot
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("importing JSONL after jj fetch: %w\nOutput: %s", err, string(output))
	}

	return nil
}

// runJJPrePush runs the pre-push equivalent for jj: ensure JSONL is
// up-to-date before jj git push.
func runJJPrePush(ctx context.Context, repoRoot string) error {
	// Check if we're in a bd workspace
	beadsDir := filepath.Join(repoRoot, ".beads")
	if _, err := os.Stat(beadsDir); os.IsNotExist(err) {
		return nil
	}

	// Flush pending changes first
	// #nosec G204 -- command is hardcoded
	flushCmd := exec.CommandContext(ctx, "bd", "sync", "--flush-only", "--no-daemon")
	flushCmd.Dir = repoRoot
	if output, err := flushCmd.CombinedOutput(); err != nil {
		return fmt.Errorf("flushing JSONL before jj push: %w\nOutput: %s", err, string(output))
	}

	// jj automatically tracks all file changes (no staging area), so we
	// don't need the git-style "check for unstaged changes" logic. Instead,
	// snapshot to make sure jj sees the flushed files.
	// #nosec G204 -- command is hardcoded
	snapCmd := exec.CommandContext(ctx, "jj", "status")
	snapCmd.Dir = repoRoot
	_ = snapCmd.Run() // triggers snapshot; ignore errors

	return nil
}

// jjHookWrapperScript returns the shell script content for a jj wrapper.
// hookName is the bd hook to run (e.g. "pre-commit").
// jjCommand is the jj command to exec (e.g. "jj commit").
func jjHookWrapperScript(hookName string, jjCommand string) string {
	// Split the jj command for the exec line
	parts := strings.Fields(jjCommand)
	execLine := fmt.Sprintf("exec %s \"$@\"", strings.Join(parts, " "))

	var sb strings.Builder
	sb.WriteString("#!/usr/bin/env bash\n")
	sb.WriteString("# Generated by bd hooks install (jj mode)\n")
	sb.WriteString("# Wrapper: run bd hook then exec jj command\n")
	sb.WriteString("#\n")
	sb.WriteString(fmt.Sprintf("# Hook: %s\n", hookName))
	sb.WriteString(fmt.Sprintf("# Command: %s\n", jjCommand))
	sb.WriteString("set -euo pipefail\n")
	sb.WriteString("\n")
	sb.WriteString(fmt.Sprintf("bd hooks run %s || exit $?\n", hookName))
	sb.WriteString(execLine)
	sb.WriteString("\n")

	return sb.String()
}
